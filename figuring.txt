Alright so, we have these two dictionaries with, what I think are the same keys, but their values are complex. They are the dataframes of price or entries associated with the symbol.
Essentially entire .csv files are the values in the key-value pair of these dictionaries.

The first thing to do is to check and confirm that both of the dictionaries 'price_data_dict' and 'trade_entries_dict' have some/all of the same keys.
Nice, this code confirms that all 14 keys are identical:

# Get the set of keys for each dictionary
keys1 = set(price_data_dict.keys())
keys2 = set(trade_entries_dict.keys())

# Get the intersection of the two sets
shared_keys = keys1.intersection(keys2)

# Check if there are any shared keys
if shared_keys:
    print(f"The dictionaries share the following keys: {shared_keys}")
else:
    print("The dictionaries do not share any keys.")

Alright, so they have all the same keys. But they have complex, weird values associated with each of their keys.
They are both .csv files basically, but they have different columns. The only similar column in the dataframes are 'datetime'

Ideally, I want to be able to say 'if the datetime is the same for both dictionaries, then add the columns from one dicionary with the other.'

It's kind of like merging the two dictionaries, but since the keys are the same, its just gonna be altering the values of the key-value pairs to include rows from the other dictionaries values.


This checks if the datetime index was in correct format, can also do it for the other dictionary:
"for key, value in trade_entries_dict.items():
    if value.index.dtype != 'datetime64[ns]':
        print(f"datetime index in {key} is not in datetime format.")
    else:
        print(f"datetime index in {key} is in datetime format.")"


Sets the row viewing back to the small amount: pd.options.display.max_rows = 100
View all rows: "pd.set_option('display.max_rows', None)  # To show all rows"

You can view all 13 columns at once with a single symbol, but can't for the entire dict. 'price_and_trades_dict['A']' will show all perfectly.

FINAL FIGURING:	

Background information: 

'price_and_trades_dict' is the dictionary where we will be getting all the data from. It's keys are stock symbols, such as 'A', 'ABB' etc. The values are DataFrames which have the historical price data and trade strategy data of that stock. The index of the DataFrames is the date which is denoted 'datetime'. The DataFrames have 13 columns: "open, high, low, close, volume, entry, target, stop, risk:reward, target_pct, stop_pct, target_profit, position_size". 

The goals:

I started to make a function called 'create_trade_results_dict'. The functions goal is to create and fill data in a new dictionary called 'trade_results_dict'. The dictionary 'trade_results_dict' will have the exact same keys as the 'price_and_trades_dict'. The values for each key will also be DataFrames, but with the following new index and new columns:
The index will be 'trade_num', and the columns will be: 'entry_date' 'exit_date' 'days_in_trade' 'win_loss' 'p_l'. Explanation on them in depth later on.

I want the new dictionary 'trade_results_dict' to look something like this:

{'A': 							
Trade_Num	entry_date	exit_date	days_in_trade		win_loss	p_l	
1	3/12/2018	3/14/2018	2		1	150	
2	3/19/2018	3/21/2018	2		1	150	
3	3/27/2018	4/16/2018	20		-1	-100	
4	4/19/2018	4/20/2018	1		1	150	
5	5/2/2018	5/9/2018	7		-1	-100	
6	5/11/2018	5/12/2018	1		-1	-100	
7	5/14/2018	5/16/2018	2		-1	-100	
8	5/21/2018	5/30/2018	9		1	150	}

My idea on how to achieve this:		

Firstly, I think 'price_and_trades_dict' will have to be an input/argument for our function so we can analyze and iterate through it. Also, I think we have to iterate through the 'price_and_trades_dict' at least once to get data for our new dictionaries values (DataFrames which will hold the trade number as it's index and then columns which will hold: entry date, exit date, days in trade, win loss amount, and profit loss amount.) Next we'll have to declare the new dictionary, so this first part might look something like this:

def create_trade_results_dict(price_and_trades_dict):
    trade_results_dict = {}

Does this look like a good start so far? Is there anything you need me to explain further or you would like to change?

My idea is to have 2 loops which iterate through the DataFrames to get the trade results of a trade entry.

Loop 1: This loop will go through all the key-value pairs in the 'price_and_trades_dict', specifically looking to iterate through the 'target' and 'stop' columns of the values DataFrames for each stock. I need to check and see which rows have positive numbers for both of these columns, basically making sure they are valid with data in them.		

If that loop, or check, finds a row with valid data for 'target' and 'stop' columns, then I think we need a second loop to actually compare the trade entry data with the historical price data and see how the trade did (did it win or lose, what was the profit loss, entry and exit date, number of days held).
		
Loop 2: If 'target' and 'stop' columns have positive numbers in that row, starting from that row, iterate through every key's value DataFrame and see how the 'open', 'high', 'low', 'close', column numbers compare to the 'target' and 'stop' numbers for that row. The loop would continue until either the 'target_condition_met' or 'stop_condition_met' are satisfied. 

In depth explanation of the new dictionary 'trade_results_dict' we will be creating and filling:

The index which will be "trade_num", starting at 1 and increasing by 1 for every row. Simply tracking the trade number.
The 'entry_date' column, which will be the datetime index for where the first loop found positive numbers for 'target' and 'stop' columns.
The 'exit_date' column, which will be the datetime index for when 'target_condition_met' or 'stop_condition_met' were first satisfied.
The 'days_in_trade' column which will subtract the 'exit_date' from the 'entry_date' to find the number of days the trade was held.  					
The 'win_loss' column, which will output 1 if the 'target_condition_met' was satisfied, or -1 if the 'stop_condition_met' was satisfied.						
The 'p_l' column, which will output 150 if win_loss is 1, or -100 if win_loss is -1.

target_condition = 'target <= open or target <= high or target <= low or target <= close'						
stop_condition_met = 'stop >= open or stop >= high or stop >= low or stop >= close'		
															



